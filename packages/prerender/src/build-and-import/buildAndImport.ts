import fs from 'node:fs'
import path from 'node:path'

import alias from '@rollup/plugin-alias'
import commonjs from '@rollup/plugin-commonjs'
import { nodeResolve } from '@rollup/plugin-node-resolve'
import replace from '@rollup/plugin-replace'
import { rollup } from 'rollup'
import unimportPlugin from 'unimport/unplugin'

import { getConfig, getPaths } from '@cedarjs/project-config'

import {
  getPathsFromTypeScriptConfig,
  parseTypeScriptConfigFiles,
} from '../internal.js'

import { cellTransformPlugin } from './rollupPlugins/rollup-plugin-cedarjs-cell.js'
import { cedarjsDirectoryNamedImportPlugin } from './rollupPlugins/rollup-plugin-cedarjs-directory-named-imports.js'
import { externalPlugin } from './rollupPlugins/rollup-plugin-cedarjs-external.js'
import { ignoreHtmlAndCssImportsPlugin } from './rollupPlugins/rollup-plugin-cedarjs-ignore-html-and-css-imports.js'
import { injectFileGlobalsPlugin } from './rollupPlugins/rollup-plugin-cedarjs-inject-file-globals.js'
import { cedarjsPrerenderMediaImportsPlugin } from './rollupPlugins/rollup-plugin-cedarjs-prerender-media-imports.js'
import { cedarjsRoutesAutoLoaderPlugin } from './rollupPlugins/rollup-plugin-cedarjs-routes-auto-loader.js'
import { typescriptPlugin } from './rollupPlugins/rollup-plugin-cedarjs-typescript.js'
import { getPkgType, isValidJsFile, makeFilePath } from './utils.js'

/** @see {@link https://github.com/rollup/plugins/issues/1541} */
const fix = <T>(f: { default: T }): T => f as unknown as T

const tsconfigPathsToRegExp = (paths: Record<string, any>) => {
  return Object.keys(paths || {}).map((key) => {
    return new RegExp(`^${key.replace(/\*/g, '.*')}$`)
  })
}

interface Options {
  /** The filepath to bundle and require */
  filepath: string

  /**
   * Preserve compiled temporary file for debugging
   * Default to `process.env.BUNDLE_REQUIRE_PRESERVE`
   */
  preserveTemporaryFile?: boolean
}

export async function buildAndImport(
  options: Options,
): Promise<Record<string, React.FunctionComponent>> {
  if (!isValidJsFile(options.filepath)) {
    throw new Error(`${options.filepath} is not a valid JS file`)
  }

  const tsConfigs = parseTypeScriptConfigFiles()

  const resolvePaths = tsconfigPathsToRegExp(
    tsConfigs.web?.compilerOptions?.paths || {},
  )

  // Need the project config to know if trusted graphql documents is being used
  // and decide to use the gql tag import or the trusted document gql function
  // generated by code gen client preset
  const config = getConfig()

  const useTrustedDocumentsGqlTag = config.graphql.trustedDocuments

  const webBase = getPaths().web.base
  const outDir = path.join(getPaths().web.dist, '__prerender')

  if (!fs.existsSync(outDir)) {
    fs.mkdirSync(outDir, { recursive: true })
  }

  const build = await rollup({
    input: [options.filepath],
    output: {
      dir: outDir,
    },
    jsx: 'react-jsx',
    logLevel: 'debug',
    external: ['react', 'react-dom'],
    plugins: [
      externalPlugin({
        notExternal: resolvePaths,
        filepath: options.filepath,
      }),
      nodeResolve({
        preferBuiltins: true,
        exportConditions: ['node'],
        extensions: ['.js', '.jsx', '.ts', '.tsx', '.mjs', '.cjs'],
      }),
      // @ts-expect-error - Ignore type errors for now
      replace({
        preventAssignment: true,
        'process.env.NODE_ENV': '"production"',
      }),
      fix(alias)({
        entries: [
          {
            find: 'src',
            replacement: getPaths().web.src,
          },
          {
            find: '$api',
            replacement: getPaths().api.base,
          },
          ...getPathsFromTypeScriptConfig(tsConfigs.web, webBase),
        ],
      }),
      ignoreHtmlAndCssImportsPlugin(),
      cellTransformPlugin(),
      cedarjsRoutesAutoLoaderPlugin(),
      cedarjsDirectoryNamedImportPlugin(),
      cedarjsPrerenderMediaImportsPlugin(),
      fix(commonjs)(),
      typescriptPlugin(options.filepath, tsConfigs.web),
      unimportPlugin.rollup({
        imports: [
          // import React from 'react'
          {
            name: 'default',
            as: 'React',
            from: 'react',
          },
          // import { gql } from 'graphql-tag'
          {
            name: 'gql',
            from: 'graphql-tag',
          },
          // import { gql } from 'src/graphql/gql'
          useTrustedDocumentsGqlTag && {
            name: 'gql',
            from: `src/graphql/gql.js`,
          },
        ].filter(<T>(v?: T | false): v is T => Boolean(v)),
      }),
      injectFileGlobalsPlugin(),
    ],
  })

  try {
    const { output } = await build.generate({
      dir: outDir,
      format: getPkgType() === 'module' ? 'es' : 'cjs',
      exports: 'auto',
      sourcemap: 'inline',
    })

    for (const chunk of output) {
      if (chunk.type !== 'chunk') {
        throw new Error('[bundle-require] Expected chunk output')
      }

      const chunkPath = path.join(outDir, chunk.fileName)

      await fs.promises.writeFile(chunkPath, chunk.code, 'utf8')
    }

    const importPath = makeFilePath(path.join(outDir, output[0].fileName))

    return import(importPath)
  } finally {
    if (!options.preserveTemporaryFile) {
      // Remove the output files after execution
      await fs.promises.rm(outDir, { recursive: true, force: true })
    }

    await build.close()
  }
}
