import fs from 'node:fs'
import path from 'node:path'

import alias from '@rollup/plugin-alias'
import commonjs from '@rollup/plugin-commonjs'
import { nodeResolve } from '@rollup/plugin-node-resolve'
import replace from '@rollup/plugin-replace'
import { loadTsConfig } from 'load-tsconfig'
import { rollup } from 'rollup'
import unimportPlugin from 'unimport/unplugin'

import { getConfig, getPaths } from '@cedarjs/project-config'

import {
  getPathsFromTypeScriptConfig,
  parseTypeScriptConfigFiles,
} from '../internal'
import { cellTransformPlugin } from '../rollupPlugins/rollup-plugin-cedarjs-cell'
import { cedarjsDirectoryNamedImportPlugin } from '../rollupPlugins/rollup-plugin-cedarjs-directory-named-imports'
import { externalPlugin } from '../rollupPlugins/rollup-plugin-cedarjs-external'
import { ignoreHtmlAndCssImportsPlugin } from '../rollupPlugins/rollup-plugin-cedarjs-ignore-html-and-css-imports'
import { injectFileGlobalsPlugin } from '../rollupPlugins/rollup-plugin-cedarjs-inject-file-globals'
import { cedarjsPrerenderMediaImportsPlugin } from '../rollupPlugins/rollup-plugin-cedarjs-prerender-media-imports'
import { cedarjsRoutesAutoLoaderPlugin } from '../rollupPlugins/rollup-plugin-cedarjs-routes-auto-loader'
import { typescriptPlugin } from '../rollupPlugins/rollup-plugin-cedarjs-typescript'

import type { Options } from './types'
import { guessFormat, isValidJsFile, setPrerenderChunkIds } from './utils'

const tsconfigPathsToRegExp = (paths: Record<string, any>) => {
  return Object.keys(paths || {}).map((key) => {
    return new RegExp(`^${key.replace(/\*/g, '.*')}$`)
  })
}

export async function buildAndImport(
  options: Options,
): Promise<Record<string, React.FunctionComponent>> {
  if (!isValidJsFile(options.filepath)) {
    throw new Error(`${options.filepath} is not a valid JS file`)
  }

  const cwd = options.cwd || process.cwd()
  const tsconfig =
    options.tsconfig === false
      ? undefined
      : typeof options.tsconfig === 'string' || !options.tsconfig
        ? loadTsConfig(cwd, options.tsconfig)
        : { data: options.tsconfig, path: undefined }

  const resolvePaths = tsconfigPathsToRegExp(
    tsconfig?.data.compilerOptions?.paths || {},
  )

  // Need the project config to know if trusted graphql documents is being used
  // and decide to use the gql tag import or the trusted document gql function
  // generated by code gen client preset
  const config = getConfig()

  const useTrustedDocumentsGqlTag = config.graphql.trustedDocuments

  const tsConfigs = parseTypeScriptConfigFiles()
  const webBase = getPaths().web.base
  const outDir = path.join(getPaths().web.dist, '__prerender')

  if (!fs.existsSync(outDir)) {
    fs.mkdirSync(outDir, { recursive: true })
  }

  const build = await rollup({
    input: [options.filepath],
    output: {
      dir: outDir,
    },
    jsx: 'react-jsx',
    logLevel: 'debug',
    external: ['react', 'react-dom'],
    plugins: [
      externalPlugin({
        external: options.external,
        notExternal: [...(options.notExternal || []), ...resolvePaths],
        filepath: options.filepath,
        externalNodeModules: options.externalNodeModules,
      }),
      nodeResolve({
        preferBuiltins: true,
        exportConditions: ['node'],
        extensions: ['.js', '.jsx', '.ts', '.tsx', '.mjs', '.cjs'],
      }),
      replace({
        preventAssignment: true,
        'process.env.NODE_ENV': '"production"',
      }),
      alias({
        entries: [
          {
            find: 'src',
            replacement: getPaths().web.src,
          },
          {
            find: '$api',
            replacement: getPaths().api.base,
          },
          ...getPathsFromTypeScriptConfig(tsConfigs.web, webBase),
        ],
      }),
      ignoreHtmlAndCssImportsPlugin(),
      cellTransformPlugin(),
      cedarjsRoutesAutoLoaderPlugin({ forPrerender: true }),
      cedarjsDirectoryNamedImportPlugin(),
      cedarjsPrerenderMediaImportsPlugin(),
      commonjs(),
      typescriptPlugin(options.filepath, tsconfig),
      unimportPlugin.rollup({
        imports: [
          // import React from 'react'
          {
            name: 'default',
            as: 'React',
            from: 'react',
          },
          // import gql from 'graphql-tag'
          !useTrustedDocumentsGqlTag && {
            name: 'default',
            as: 'gql',
            from: 'graphql-tag',
          },
          // import { gql } from 'src/graphql/gql'
          useTrustedDocumentsGqlTag && {
            name: 'gql',
            from: `web/src/graphql/gql`,
          },
        ].filter(<T>(v?: T | false): v is T => Boolean(v)),
      }),
      injectFileGlobalsPlugin(),
    ],
  })

  try {
    const format = options.format ?? guessFormat(options.filepath)

    const { output } = await build.generate({
      dir: outDir,
      format: format === 'esm' ? 'es' : 'cjs',
      exports: 'auto',
      sourcemap: 'inline',
    })

    for (const chunk of output) {
      if (chunk.type !== 'chunk') {
        throw new Error('[bundle-require] Expected chunk output')
      }

      const code = setPrerenderChunkIds(chunk.code, chunk.dynamicImports)
      const chunkPath = path.join(outDir, chunk.fileName)

      await fs.promises.writeFile(chunkPath, code, 'utf8')
    }

    const outPath = path.join(outDir, output[0].fileName)

    // Convert Windows absolute paths to file:// URLs for ESM import
    let importPath = outPath
    if (process.platform === 'win32' && path.isAbsolute(outPath)) {
      // Convert backslashes to forward slashes and prepend file://
      importPath = `file:///${outPath.replace(/\\/g, '/')}`
    }

    return import(importPath)
  } finally {
    if (!options.preserveTemporaryFile) {
      // Remove the output files after execution
      await fs.promises.rm(outDir, { recursive: true, force: true })
    }

    await build.close()
  }
}
