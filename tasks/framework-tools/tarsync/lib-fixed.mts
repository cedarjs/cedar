import { fileURLToPath } from 'node:url'
import { parseArgs as nodeUtilParseArgs } from 'node:util'

import ansis from 'ansis'
import { $, cd, fs, glob, path, within } from 'zx'

export const TARBALL_DEST_DIRNAME = 'tarballs'

export const FRAMEWORK_PATH = fileURLToPath(
  new URL('../../../', import.meta.url),
)

export const IGNORE_EXTENSIONS = ['.DS_Store']

/**
 * Add to this array of strings, RegExps, or functions (whichever makes the most sense)
 * to ignore files that we don't want triggering package rebuilds.
 */
export const IGNORED = [
  /node_modules/,

  /packages\/codemods/,
  /packages\/create-cedar-app/,

  /dist/,

  /__fixtures__/,
  /__mocks__/,
  /__tests__/,
  /\.test\./,
  /jest.config.{js,ts}/,

  /README.md/,

  // esbuild emits meta.json files that we sometimes suffix.
  /meta.(\w*\.?)json/,

  /tsconfig.tsbuildinfo/,
  /tsconfig.build.tsbuildinfo/,
  /tsconfig.cjs.tsbuildinfo/,

  // The tarballs generated by `yarn build:pack`
  /cedar-.*\.tgz$/,

  (filePath: string) => IGNORE_EXTENSIONS.some((ext) => filePath.endsWith(ext)),
]

export interface Options {
  projectPath: string
  watch: boolean
  verbose: boolean
}

export async function getOptions(): Promise<Options> {
  const { positionals, values } = nodeUtilParseArgs({
    allowPositionals: true,
    options: {
      verbose: {
        type: 'boolean',
        default: false,
        short: 'v',
      },
      watch: {
        type: 'boolean',
        default: false,
        short: 'w',
      },
    },
  })
  const [projectPath] = positionals

  const options: Options = {
    projectPath: projectPath ?? process.env.RWJS_CWD ?? '',
    watch: values.watch ?? false,
    verbose: values.verbose ?? false,
  }

  if (!options.projectPath) {
    throw new Error(
      [
        'Error: You have to provide the path to a Redwood project as',
        '',
        '  1. the first positional argument',
        '',
        ansis.gray('  yarn project:tarsync /path/to/redwood/project'),
        '',
        '  2. the `RWJS_CWD` env var',
        '',
        ansis.gray('  RWJS_CWD=/path/to/redwood/project yarn project:tarsync'),
      ].join('\n'),
    )
  }

  // This makes `projectPath` an absolute path and throws if it doesn't exist.
  options.projectPath = await fs.realpath(options.projectPath)

  return options
}

/**
 * Validates that a package has the expected build artifacts.
 */
async function validatePackageBuildArtifacts(packageName: string): Promise<boolean> {
  const packagePath = `./packages/${packageName}`

  if (!await fs.pathExists(packagePath)) {
    console.warn(ansis.yellow(`‚ö†Ô∏è  Package directory not found: ${packagePath}`))
    return false
  }

  const distPath = path.join(packagePath, 'dist')
  const configPath = path.join(packagePath, 'config')

  const distExists = await fs.pathExists(distPath)
  const configExists = await fs.pathExists(configPath)

  if (!distExists) {
    console.error(ansis.red(`‚ùå Missing dist directory for ${packageName}: ${distPath}`))
    return false
  }

  if (packageName === 'testing' && !configExists) {
    console.error(ansis.red(`‚ùå Missing config directory for ${packageName}: ${configPath}`))
    return false
  }

  // For testing package, verify specific critical files
  if (packageName === 'testing') {
    const criticalFiles = [
      'dist/api/index.js',
      'dist/web/index.js',
      'config/jest/api/jest-preset.js',
      'config/jest/web/jest-preset.js',
    ]

    for (const file of criticalFiles) {
      const filePath = path.join(packagePath, file)
      if (!await fs.pathExists(filePath)) {
        console.error(ansis.red(`‚ùå Missing critical file for ${packageName}: ${filePath}`))
        return false
      }
    }
  }

  return true
}

/**
 * Waits for file system operations to complete and validates artifacts.
 */
async function waitForFileSystemSync(packageNames: string[] = ['testing'], maxAttempts = 10): Promise<void> {
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    console.log(ansis.cyan(`‚è≥ Validating build artifacts (attempt ${attempt}/${maxAttempts})...`))

    // Force file system sync
    await $`sync`

    // Wait for file operations to settle
    await new Promise(resolve => setTimeout(resolve, 1000 * attempt))

    // Validate all packages
    let allValid = true
    for (const packageName of packageNames) {
      const isValid = await validatePackageBuildArtifacts(packageName)
      if (!isValid) {
        allValid = false
        console.log(ansis.yellow(`üîÑ Package ${packageName} artifacts not ready, retrying...`))
        break
      }
    }

    if (allValid) {
      console.log(ansis.green(`‚úÖ All build artifacts validated successfully`))
      return
    }

    if (attempt === maxAttempts) {
      throw new Error(`‚ùå Build artifacts validation failed after ${maxAttempts} attempts`)
    }
  }
}

/**
 * Improved buildTarballs with explicit synchronization and validation.
 */
export async function buildTarballs(): Promise<void> {
  console.log(ansis.green('\nüîß Building tarballs with improved reliability'))

  const isCI = process.env.CI === 'true'
  console.log(`Environment: ${isCI ? 'CI' : 'Local'}`)

  try {
    if (isCI) {
      // In CI, use the more reliable approach
      await buildTarballsWithExplicitSteps()
    } else {
      // Locally, try the optimized cached approach first
      try {
        await buildTarballsWithCache()
      } catch (error) {
        console.log(ansis.yellow('‚ö†Ô∏è  Cached approach failed, falling back to explicit steps'))
        await buildTarballsWithExplicitSteps()
      }
    }

    console.log(ansis.green('‚úÖ Tarball building completed successfully'))

  } catch (error) {
    console.error(ansis.red('‚ùå Tarball building failed:'), error)
    throw error
  }
}

/**
 * Build tarballs using cached approach (faster, but can have cache issues).
 */
async function buildTarballsWithCache(): Promise<void> {
  console.log(ansis.yellow('üì¶ Building tarballs with caching enabled...'))

  // Clear cache to ensure fresh build
  await $`yarn nx reset`

  // Run build:pack with dependencies (includes build step)
  await $`yarn nx run-many -t build:pack --exclude create-cedar-app`

  // Validate critical packages
  await waitForFileSystemSync(['testing'])
}

/**
 * Build tarballs with explicit steps and synchronization (more reliable in CI).
 */
async function buildTarballsWithExplicitSteps(): Promise<void> {
  console.log(ansis.yellow('üì¶ Building tarballs with explicit synchronization...'))

  console.log(ansis.cyan('üî® Step 1: Running build step'))
  await $`sync`
  await $`yarn nx run-many -t build --exclude create-cedar-app --skipNxCache --skipRemoteCache --verbose`
  await $`sync`

  // Wait for build artifacts to be ready
  console.log(ansis.cyan('‚è≥ Waiting for build artifacts...'))
  await waitForFileSystemSync(['testing'])

  console.log(ansis.cyan('üì¶ Step 2: Running build:pack step'))
  await $`sync`
  await $`yarn nx run-many -t build:pack --exclude create-cedar-app --skipNxCache --skipRemoteCache --verbose`
  await $`sync`

  // Final validation
  await waitForFileSystemSync(['testing'])
}

/**
 * Alternative approach: Build packages sequentially to avoid race conditions.
 */
export async function buildTarballsSequentially(): Promise<void> {
  console.log(ansis.green('\nüîß Building tarballs sequentially'))

  // Get all packages that need to be built
  const workspaces = JSON.parse((await $`yarn workspaces list --json`).stdout.trim().split('\n').map(line => line).join('\n'))
  const packages = workspaces
    .filter((ws: any) => ws.name && ws.name !== 'create-cedar-app' && ws.name.startsWith('@cedarjs/'))
    .map((ws: any) => ws.name)

  console.log(`Building ${packages.length} packages sequentially...`)

  for (const packageName of packages) {
    const shortName = packageName.replace('@cedarjs/', '')
    console.log(ansis.cyan(`üî® Building ${packageName}...`))

    try {
      // Build the package
      await $`yarn nx run ${shortName}:build --skipNxCache --skipRemoteCache`
      await $`sync`

      // Validate the package
      await validatePackageBuildArtifacts(shortName)

      // Create tarball
      await $`yarn nx run ${shortName}:build:pack --skipNxCache --skipRemoteCache`
      await $`sync`

      console.log(ansis.green(`‚úÖ Completed ${packageName}`))

    } catch (error) {
      console.error(ansis.red(`‚ùå Failed to build ${packageName}:`), error)
      throw error
    }
  }

  console.log(ansis.green('‚úÖ All packages built successfully'))
}

export async function moveTarballs(projectPath: string) {
  const tarballDest = path.join(projectPath, TARBALL_DEST_DIRNAME)
  await fs.ensureDir(tarballDest)

  const tarballs = await glob(['./packages/**/*.tgz'])

  await Promise.all(
    tarballs.map((tarball) =>
      fs.move(tarball, path.join(tarballDest, path.basename(tarball)), {
        overwrite: true,
      }),
    ),
  )
}

export async function updateResolutions(projectPath: string) {
  const resolutions = (await $`yarn workspaces list --json`).stdout
    .trim()
    .split('\n')
    .map((line) => JSON.parse(line))
    // Filter out the root workspace.
    .filter(({ name }) => name)
    .reduce((resolutions, { name }) => {
      return {
        ...resolutions,
        // Turn a Redwood package name like `@cedarjs/project-config` into `cedarjs-project-config.tgz`.
        [name]: `./${TARBALL_DEST_DIRNAME}/${
          name.replace('@', '').replaceAll('/', '-') + '.tgz'
        }`,
      }
    }, {})

  const projectPackageJsonPath = path.join(projectPath, 'package.json')
  const projectPackageJson = await fs.readJSON(projectPackageJsonPath)

  await fs.writeJSON(
    projectPackageJsonPath,
    {
      ...projectPackageJson,
      resolutions: {
        ...projectPackageJson.resolutions,
        ...resolutions,
        ...(await getReactResolutions()),
      },
    },
    {
      spaces: 2,
    },
  )
}

export async function getReactResolutions() {
  const packageConfig = await fs.readJson(
    path.join(FRAMEWORK_PATH, 'packages/web/package.json'),
  )

  const react = packageConfig.peerDependencies.react
  const reactDom = packageConfig.peerDependencies['react-dom']

  if (!react || !reactDom) {
    throw new Error(
      "Couldn't find react or react-dom in @cedarjs/web's peerDependencies",
    )
  }

  return {
    react,
    'react-dom': reactDom,
  }
}

export async function yarnInstall(projectPath: string) {
  await within(async () => {
    cd(projectPath)
    await $`yarn install`
  })
}
