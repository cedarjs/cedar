import { fileURLToPath } from 'node:url'
import { parseArgs as nodeUtilParseArgs } from 'node:util'

import ansis from 'ansis'
import { $, cd, fs, glob, path, within } from 'zx'

export const TARBALL_DEST_DIRNAME = 'tarballs'

export const FRAMEWORK_PATH = fileURLToPath(
  new URL('../../../', import.meta.url),
)

export const IGNORE_EXTENSIONS = ['.DS_Store']

/**
 * Add to this array of strings, RegExps, or functions (whichever makes the most sense)
 * to ignore files that we don't want triggering package rebuilds.
 */
export const IGNORED = [
  /node_modules/,

  /packages\/codemods/,
  /packages\/create-cedar-app/,

  /dist/,

  /__fixtures__/,
  /__mocks__/,
  /__tests__/,
  /\.test\./,
  /jest.config.{js,ts}/,

  /README.md/,

  // esbuild emits meta.json files that we sometimes suffix.
  /meta.(\w*\.?)json/,

  /tsconfig.tsbuildinfo/,
  /tsconfig.build.tsbuildinfo/,
  /tsconfig.cjs.tsbuildinfo/,

  // The tarballs generated by `yarn build:pack`
  /cedar-.*\.tgz$/,

  (filePath: string) => IGNORE_EXTENSIONS.some((ext) => filePath.endsWith(ext)),
]

export interface Options {
  projectPath: string
  watch: boolean
  verbose: boolean
}

export async function getOptions(): Promise<Options> {
  const { positionals, values } = nodeUtilParseArgs({
    allowPositionals: true,
    options: {
      verbose: {
        type: 'boolean',
        default: false,
        short: 'v',
      },
      watch: {
        type: 'boolean',
        default: false,
        short: 'w',
      },
    },
  })
  const [projectPath] = positionals

  const options: Options = {
    projectPath: projectPath ?? process.env.RWJS_CWD ?? '',
    watch: values.watch ?? false,
    verbose: values.verbose ?? false,
  }

  if (!options.projectPath) {
    throw new Error(
      [
        'Error: You have to provide the path to a Redwood project as',
        '',
        '  1. the first positional argument',
        '',
        ansis.gray('  yarn project:tarsync /path/to/redwood/project'),
        '',
        '  2. the `RWJS_CWD` env var',
        '',
        ansis.gray('  RWJS_CWD=/path/to/redwood/project yarn project:tarsync'),
      ].join('\n'),
    )
  }

  // This makes `projectPath` an absolute path and throws if it doesn't exist.
  options.projectPath = await fs.realpath(options.projectPath)

  return options
}

// Debug utility functions
async function debugPackageState(packageName: string, step: string) {
  console.log(ansis.blue(`\n=== DEBUG: ${packageName} - ${step} ===`))
  console.log(`Timestamp: ${new Date().toISOString()}`)
  console.log(`Working directory: ${process.cwd()}`)

  const packagePath = `./packages/${packageName}`

  if (await fs.pathExists(packagePath)) {
    console.log(`Package directory exists: ${packagePath}`)

    // Check critical directories
    const distPath = path.join(packagePath, 'dist')
    const configPath = path.join(packagePath, 'config')

    console.log(`Dist directory exists: ${await fs.pathExists(distPath)}`)
    if (await fs.pathExists(distPath)) {
      try {
        const distContents = await fs.readdir(distPath, { recursive: true })
        console.log(`Dist contents (${distContents.length} items):`)
        distContents.slice(0, 20).forEach(item => console.log(`  ${item}`))
        if (distContents.length > 20) {
          console.log(`  ... and ${distContents.length - 20} more items`)
        }
      } catch (error) {
        console.log(`Error reading dist directory: ${error}`)
      }
    }

    console.log(`Config directory exists: ${await fs.pathExists(configPath)}`)
    if (await fs.pathExists(configPath)) {
      try {
        const configContents = await fs.readdir(configPath, { recursive: true })
        console.log(`Config contents (${configContents.length} items):`)
        configContents.forEach(item => console.log(`  ${item}`))
      } catch (error) {
        console.log(`Error reading config directory: ${error}`)
      }
    }

    // Check for existing tarballs
    try {
      const tarballs = await glob([`${packagePath}/*.tgz`])
      console.log(`Existing tarballs: ${tarballs.length}`)
      tarballs.forEach(tarball => console.log(`  ${tarball}`))
    } catch (error) {
      console.log(`Error checking for tarballs: ${error}`)
    }
  } else {
    console.log(`Package directory does not exist: ${packagePath}`)
  }

  console.log(ansis.blue(`=== END DEBUG: ${packageName} - ${step} ===\n`))
}

async function debugNxState(step: string) {
  console.log(ansis.cyan(`\n=== NX DEBUG: ${step} ===`))
  console.log(`Timestamp: ${new Date().toISOString()}`)

  // Check Nx cache
  try {
    const nxCacheDir = '.nx/cache'
    if (await fs.pathExists(nxCacheDir)) {
      const cacheContents = await fs.readdir(nxCacheDir)
      console.log(`Nx cache entries: ${cacheContents.length}`)
    } else {
      console.log('Nx cache directory does not exist')
    }
  } catch (error) {
    console.log(`Error checking Nx cache: ${error}`)
  }

  // Show current Nx environment
  console.log(`NX_CACHE_DIRECTORY: ${process.env.NX_CACHE_DIRECTORY || 'not set'}`)
  console.log(`NX_DAEMON: ${process.env.NX_DAEMON || 'not set'}`)
  console.log(`CI: ${process.env.CI || 'not set'}`)

  console.log(ansis.cyan(`=== END NX DEBUG: ${step} ===\n`))
}

export async function buildTarballs() {
  console.log(ansis.green('\n🔧 Starting buildTarballs with enhanced debugging'))

  await debugNxState('before-build')

  // Debug specific packages that are known to have issues
  const problematicPackages = ['testing'] // Add more package names as needed

  for (const pkg of problematicPackages) {
    await debugPackageState(pkg, 'before-nx-build')
  }

  console.log(ansis.yellow('\n📦 Running Nx build command...'))

  try {
    // Add explicit sync before the command
    await $`sync`

    const result = await $`yarn nx run-many -t build:pack --exclude create-cedar-app --skipNxCache --skipRemoteCache --verbose`

    console.log(ansis.green('✅ Nx build command completed'))

    // Add explicit sync after the command
    await $`sync`

    // Wait a moment for file system operations to settle
    await new Promise(resolve => setTimeout(resolve, 1000))

  } catch (error) {
    console.error(ansis.red('❌ Nx build command failed:'), error)
    throw error
  }

  await debugNxState('after-build')

  for (const pkg of problematicPackages) {
    await debugPackageState(pkg, 'after-nx-build')
  }

  console.log(ansis.green('🔧 buildTarballs completed with enhanced debugging\n'))
}

// Enhanced version with timing and file system sync
export async function buildTarballsWithExplicitSync() {
  console.log(ansis.green('\n🔧 Starting buildTarballs with explicit synchronization'))

  await debugNxState('before-build')

  console.log(ansis.yellow('\n📦 Running build step explicitly...'))

  try {
    // Step 1: Run build targets explicitly
    await $`sync`
    await $`yarn nx run-many -t build --exclude create-cedar-app --skipNxCache --skipRemoteCache --verbose`
    await $`sync`

    // Wait for file system to settle
    console.log('⏳ Waiting for file system operations to complete...')
    await new Promise(resolve => setTimeout(resolve, 2000))

    // Step 2: Run build:pack targets explicitly
    console.log(ansis.yellow('\n📦 Running build:pack step explicitly...'))
    await $`yarn nx run-many -t build:pack --exclude create-cedar-app --skipNxCache --skipRemoteCache --verbose`
    await $`sync`

    console.log(ansis.green('✅ Explicit build steps completed'))

  } catch (error) {
    console.error(ansis.red('❌ Explicit build steps failed:'), error)
    throw error
  }

  await debugNxState('after-build')

  console.log(ansis.green('🔧 buildTarballsWithExplicitSync completed\n'))
}

// Test different caching strategies
export async function buildTarballsWithCaching() {
  console.log(ansis.green('\n🔧 Testing build with different caching strategies'))

  console.log(ansis.yellow('\n📦 Strategy 1: Enable cache but clear it first...'))

  try {
    await $`yarn nx reset`
    await $`yarn nx run-many -t build:pack --exclude create-cedar-app`

    console.log(ansis.green('✅ Cached build completed'))

  } catch (error) {
    console.error(ansis.red('❌ Cached build failed:'), error)

    console.log(ansis.yellow('\n📦 Strategy 2: Fallback to no cache...'))
    await $`yarn nx run-many -t build:pack --exclude create-cedar-app --skipNxCache --skipRemoteCache`
  }

  console.log(ansis.green('🔧 buildTarballsWithCaching completed\n'))
}

export async function moveTarballs(projectPath: string) {
  const tarballDest = path.join(projectPath, TARBALL_DEST_DIRNAME)
  await fs.ensureDir(tarballDest)

  const tarballs = await glob(['./packages/**/*.tgz'])

  await Promise.all(
    tarballs.map((tarball) =>
      fs.move(tarball, path.join(tarballDest, path.basename(tarball)), {
        overwrite: true,
      }),
    ),
  )
}

export async function updateResolutions(projectPath: string) {
  const resolutions = (await $`yarn workspaces list --json`).stdout
    .trim()
    .split('\n')
    .map((line) => JSON.parse(line))
    // Filter out the root workspace.
    .filter(({ name }) => name)
    .reduce((resolutions, { name }) => {
      return {
        ...resolutions,
        // Turn a Redwood package name like `@cedarjs/project-config` into `cedarjs-project-config.tgz`.
        [name]: `./${TARBALL_DEST_DIRNAME}/${
          name.replace('@', '').replaceAll('/', '-') + '.tgz'
        }`,
      }
    }, {})

  const projectPackageJsonPath = path.join(projectPath, 'package.json')
  const projectPackageJson = await fs.readJSON(projectPackageJsonPath)

  await fs.writeJSON(
    projectPackageJsonPath,
    {
      ...projectPackageJson,
      resolutions: {
        ...projectPackageJson.resolutions,
        ...resolutions,
        ...(await getReactResolutions()),
      },
    },
    {
      spaces: 2,
    },
  )
}

export async function getReactResolutions() {
  const packageConfig = await fs.readJson(
    path.join(FRAMEWORK_PATH, 'packages/web/package.json'),
  )

  const react = packageConfig.peerDependencies.react
  const reactDom = packageConfig.peerDependencies['react-dom']

  if (!react || !reactDom) {
    throw new Error(
      "Couldn't find react or react-dom in @cedarjs/web's peerDependencies",
    )
  }

  return {
    react,
    'react-dom': reactDom,
  }
}

export async function yarnInstall(projectPath: string) {
  await within(async () => {
    cd(projectPath)
    await $`yarn install`
  })
}
